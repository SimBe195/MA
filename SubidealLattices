
l := 3;
Lat := [];

for phim in [16,18,20,22] do
    printf "Phi(m) = %o\n", phim;
    for m in EulerPhiInverse(phim) do
        
        if m mod 4 eq 2 then
            continue;
        end if;

        printf "m = %o\n", m;

        K<z> := CyclotomicField(m);
        F:=sub<K|z+1/z>;
        ZK:=Integers(K);

        A := ClassesModGalois(K);

        U, UnitGens, M := TotPosUnits(F);
        U := RedByNorm(U, K, F);


        for i in [1..#Factorization(m)] do
            p := Factorization(m)[i][1];
            printf "p = %o\n", p;
            d := m / p;

            N := Integers() ! (phim / (p-1));

            for s := 0 to Min({N, 24-phim}) do
                if p ne l then
                    if (s - (p-2)*N) mod 2 ne 0 then
                        continue;
                    end if;
                end if;

                for k := Max({0, EulerPhi(m)-12}) to Min({12, EulerPhi(m)}) do
                    if p ne l then
                        if k mod 2 ne 0 then
                            continue;
                        end if;
                    else
                        if (s+k - (p-2)*N) mod 2 ne 0 then
                            continue;
                        end if;
                    end if;

                    B := DivisorsWithNorm(ideal<ZK|p*l>, p^s*l^k);

                    for J in A do
                        JJ := (J*ConjIdeal(J,K)*Different(ZK))^(-1);

                        for I in B do
                            JJI := JJ*I;
                            pos, alpha_1 := PosGenInF(JJI, UnitGens, M, K, F);

                            if not pos then 
                                continue;
                            end if;

                            for u in U do
                                alpha := K ! u*alpha_1;
                                L := LatFromIdeal(J, alpha, K);
                            end for;

                            if not IsEven(L) then
                                continue;
                            end if;

                            new := true;
                            for M in Lat do
                                if IsIsometric(M[1], L) then
                                    new := false;
                                    break;
                                end if;
                            end for;

                            if new then
                                printf "Found a new lattice! Determinant: %o^%o*%o^%o, Minimum: %o\n", p,s,l,k,Minimum(L);
                                Append(~Lat, <L,p,d,s,k>);
                            end if;
                        end for;
                    end for;
                end for;
            end for;
        end for;

        print "";

    end for;
end for;

#Lat;