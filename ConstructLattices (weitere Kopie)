InvEulerPhi := function(d)
// Computes sorted list of positive integers for which Eulers totient function evaluates to d.
// Input:
//  d : RngIntElt   : Positive integer for which Euler-phi is reversed.
//
// Output:
//  SeqEnum         : Sorted list of results. 

    Div := Divisors(d);

    PossPrimes := [];
    for di in Div do
        if IsPrime(di+1) then
            Append(~PossPrimes, di+1);
        end if;
    end for;

    Res := [];
    for S in Subsets(SequenceToSet(PossPrimes)) do
        d_0 := d;
        Inv := 1;

        for pi in S do
            d_0 /:= (pi-1);
            Inv *:= pi;
        end for;

        if not d_0 in Integers() then
            continue;
        end if;

        poss := true;
        for fac in Factorization(Integers() ! d_0) do
            if not fac[1] in S then
                poss := false;
                break;
            end if;
            Inv *:= fac[1]^fac[2];
        end for;
        if poss then
            Append(~Res, Inv);
        end if;
    end for;

    Res := Sort(Res);

    return Res;

end function;

TotallyPositive := function(x)
// Checks whether x is a totally positiv element, i.e. if r(x) > 0 for all real embeddings r.
// Input:
//  x : FldNumElt       : Element for which positivity should be checked..
//
// Output:
//  BoolElt             : true iff x is totally positive.           

    for r in RealEmbeddings(x) do
        if not (r gt 0) then
            return false;
        end if;
    end for;

    return true;
end function;


ConjIdeal := function(I, K)
// Computes the complex conjugate of an Z_K-Ideal I.
// Input:
//  K : FldNum          : Field in which the complex conjugation takes place.
//  I : RngIdl          : Z_K-Ideal for which complex conjugate shall be computed.

// Output:
//  RngIdl              : Z_K-Ideal which is the complex conugate of I.

    gens := [];
    for g in Generators(I) do
        Append(~gens, ComplexConjugate(K ! g));
    end for;
    return ideal<Integers(K)|gens>;
end function;

ClassesModGalois := function(K)    // Credit to Michael Juergens.
// Computes a representation system of the class group of Z_K modulo the action of the Galois-group of K/Q.
// Input :
//  K : FldNum      : Numberfield for which the representative system shall be computed.

// Output :
//  SeqEnum         : List of representatives of the class group that are independent modulo Galois.
    
    ZK := Integers(K);
    Cl, mCl := ClassGroup(ZK: Bound := 1000);

    ClassesModGalois:=[];
    for a in Cl do
        A:=mCl(a);
        new:=true;
        for f in Automorphisms(K) do
            if Inverse(mCl)(ideal<ZK| [f(x) : x in Generators(A)] >) in ClassesModGalois then 
                new:=false; 
                break; 
            end if;
        end for;
        if new then Append(~ClassesModGalois,a); end if;
    end for;

    return [mCl(g) : g in ClassesModGalois];

end function;

TotPosUnits := function(F)
// Computes a list of totally positive units of the Z_F reduced by squares.
// Input:
// F : FldNum               : Totally real number-field for whose ring of integers the units shall be computed.

// Output:
// SeqEnum, SeqEnum, Mtrx   : List of square-free, totally positive units inside Z_F; list of generators of the unit group of Z_F; matrix whose entries encode the sign of the real embeddings of the unit-generators.

    ZF := Integers(F);
    dim := #Basis(F);
    Units, mUnits := IndependentUnits(ZF);
    UnitGens := [F | mUnits(Units.i) : i in [1..dim]];

    M := KMatrixSpace(GF(2), dim, dim) ! 0;
    for i in [1..dim] do
        r := RealEmbeddings(UnitGens[i]);

        for j in [1..dim] do
            if not (r[j] gt 0) then
                M[i][j] := 1;
            end if;
        end for;

    end for;

    MKernel := KernelMatrix(M);

    TotPosBasis := [];
    for i in [1..NumberOfRows(MKernel)] do
        a := F ! 1;
        for j in [1..dim] do
            if MKernel[i][j] eq 1 then
                a := a * UnitGens[j];
            end if;
        end for;
        Append(~TotPosBasis, a);
    end for;

    TotPos := [];

    for S in Subsets({1..#TotPosBasis}) do
        a := F ! 1;
        for i in S do
            a *:= TotPosBasis[i];
        end for;
        Append(~TotPos, a);
    end for;

    return TotPos, UnitGens, M;

end function;

RedByNorm := function(TotPos, K, F)
// Takes list of totally positive units and reduces it modulo {c*conj(c) | c in ZK}.
// Input:
//  TotPos : SeqEnum            : List of totally positive elements which shall be reduced.
//  ZK : RngOrd                 : Ring of integers for which the norms are tested.

// Output:
//  SeqEnum                     : Sublist of TotPos whose elements are independent by norm.

    U := [];    
    ZKF := Integers(RelativeField(F,K));
    for u in TotPos do
        new := true;

        for v in U do

            if NormEquation(ZKF, ZKF ! (u/v)) then
                new := false;
                break;
            end if;

        end for;

        if new then
            Append(~U, u);
        end if;
    end for;

    return U;

end function;

GenInF := function(I, K, F) // Credit to Michael Juergens
// Finds a generator of the ideal I that lies in F or returns false if there is none.
// Input:
//  I : RngIdl          : ZK-ideal for which a generator in F is searched.
//  K : FldNum          : Number-field that I is an ideal in.
//  F : FldNum          : Totally-real subfield of K in which a generator is searched.

// Output:
// BoolElt, FldNumElt   : true iff a generator in F exists; generator if one is found.

    RelKF:=RelativeField(F,K);
    ZK := Integers(K);
    ZF := Integers(F);

    // Boolscher Wert, der angibt, ob I überhaupt die Form I=(I meet F)O hat
    Shape:=true; 
    // Speichert das Ideal I meet F
    ImeetF:=ideal<ZF|1>;
    SplitIdeals:=[];

    for i in [1..#Factorization(I)] do
        tup := Factorization(I)[i];
        P:=tup[1];
        nuP:=tup[2];
     
        // Fasse Ideal P als Ideal von der relativen Erweiterung K:F auf
        RelP:=ideal<Integers(RelKF)|Generators(P)>;
        // Berechne die Norm von P: N(P):=P*Conjugate(P) meet F = p^f(P:p) 
        // Für die letzte Gleichheit siehe Marcus S.84 Ü14
        // Das Ideal p erhält man nun für f=1 durch p:=N(P) und im Fall f=2 durch
        // p:=N(P)^1/2.
        Relp:=Norm(RelP);
        
        p:=MinimalInteger(P);
        P_F:=Factorization(ideal< ZF | p >)[1][1];
        r := #Factorization(ideal< ZK | Generators(P_F)>);
        e := Factorization(ideal< ZK | Generators(P_F)>)[1][2];

        if r eq 1 and e eq 1 then   // Relative inert
            p:=Factorization(ideal<ZF | Generators(Relp)>)[1][1];
            ImeetF*:=p^nuP; 
        else 
            if r eq 1 and e eq 2 then // Relative ramified
                if not IsEven(nuP) then Shape:=false; break; end if; 
                p:=Factorization(ideal<ZF | Generators(Relp)>)[1][1];
                ImeetF*:=p^Ceiling(nuP/2); 
            else 
                if r eq 2 and e eq 1 then // Relative split
                    if Valuation(I,P) ne Valuation(I,ConjIdeal(P,K)) then Shape:=false; break; end if; 
                    if not ConjIdeal(P,K) in SplitIdeals then 
                        p:=Factorization(ideal<Integers(F) | Generators(Relp)>)[1][1];
                        ImeetF*:=p^nuP; 
                        Append(~SplitIdeals,P);
                        Append(~SplitIdeals,ConjIdeal(P,K)); 
                    end if; 
                end if;
            end if;                  
        end if;
    end for;

    if not Shape then
        return false, _;
    end if;

    return IsPrincipal(ImeetF);

end function;

PosGen := function(alpha, UnitGens, M)
// Finds a totally positive generator of a principal ideal alpha*Z_K
// Input:
//  alpha : FldNumElt   : Generator of the ideal.
//  M : Mtrx            : Matrix whose entries encode the sign of the embeddings of the unit-group-generators as in TotPos
//  UnitGens : SeqEnum  : List of generators of the unit-group of Z_F as in TotPos.
    
// Output:
//  BoolElt, FldNumElt  : true iff a totally positive generator exists; generator if one is found.

    dim := NumberOfRows(M);

    a := KMatrixSpace(GF(2), 1, dim) ! 0;
    r := RealEmbeddings(alpha);
    for i in [1..dim] do
        if not (r[i] gt 0) then
            a[1][i] := 1;
        end if;
    end for;

    solvable, MSol := IsConsistent(M, a);

    if not solvable then
        return false, _;
    end if;

    gen := alpha;

    for j in [1..dim] do
        if MSol[1][j] eq 1 then
            gen *:= UnitGens[j];
        end if;
    end for;

    return true, gen;

end function;

DivisorsWithNorm := function(l, n, ZK)
// Construct divisors of l*Z_K with norm l^n    
// Input:
//  l : RngIntElt       : See above.
//  n : RngIntElt       : See above.
//  ZK : RngOrd         : See above.


// Output:
//  SeqEnum             : List of divisors.

    if l eq 1 then
        return [ideal<ZK|1>];
    end if;

    A := [];

    FactZK := Factorization(l*ZK);
    a := Norm(FactZK[1][1]);
    s := #FactZK;
    b := Integers() ! (n / Log(l, a));

    for k in Divisors(Factorization(b)) do
        if k lt s/2 then
            continue;
        end if;

        IndexSets := Subsets({Integers() | 1..s}, k);

        for Indices in IndexSets do
            J := ideal<ZK | 1>;

            for i in Indices do
                J *:= FactZK[i][1]^(Integers() ! (b/k));
            end for;

            Append(~A, J);
        end for;
    end for;

    return A;
    
end function;

ModLattices := function(l, m)
// Finds all l-modular ideal-lattices in Q(zeta_m).
// Input:
//  l : RngIntElt       : See above.
//  dim : RngIntElt     : See above.

//Output:
//  SeqEnum             : List of found lattices.
    
    K<z> := CyclotomicField(m);
    F := sub<K | z + 1/z>;

    ZK := Integers(K);
    ZF := Integers(F);

    dim := EulerPhi(m);


    A := DivisorsWithNorm(l, Integers() ! (dim/2), ZK);
    B := ClassesModGalois(K);

    princ, alpha_0 := GenInF(Different(ZK)^(-1), K, F);
    if not princ then
        print "Error: Inverse different has no generator in F.";
        return [];
    end if;

    TotPos, UnitGens, M := TotPosUnits(F);

    pos, alpha_0 := PosGen(alpha_0, UnitGens, M);
    InvDiffPos := pos;
    if not pos then
        print("Error: Inverse different has not totally positive generator.");
        return [];
    end if;

    U := RedByNorm(TotPos, K, F);

    Lattices := [];

    for I in A do
        for J in B do
            JJI := (J * ConjIdeal(J,K))^(-1) * I * alpha_0;

            princ, alpha_1 := GenInF(JJI, K, F);

            if not princ then
                continue;
            end if;

            pos, alpha_1 := PosGen(alpha_1, UnitGens, M);

            for u in U do
                alpha := K ! (u * alpha_1);

                JGenerators := ZeroMatrix(Integers(), #Generators(J)*dim, dim);
                g1 := K!Generators(J)[1];
                if #Generators(J) gt 1 then
                    g2 := K!Generators(J)[2];
                end if;

                for i in [1..dim] do
                    JGenerators[i] := Vector(Integers(), dim, Eltseq(g1*z^(i-1)));
                    if #Generators(J) gt 1 then
                        JGenerators[dim+i] := Vector(Integers(), dim, Eltseq(g2*z^(i-1)));
                    end if;
                end for;


                ZBaseVecs := Basis(RowSpace(JGenerators));
                ZBase := [];
                for i in [1..dim] do
                    b := K ! 0;
                    for j in [1..dim] do
                        b +:= ZBaseVecs[i][j]*z^(j-1);
                    end for;
                    Append(~ZBase, b);
                end for;

                Gram := KMatrixSpace(Rationals(), dim, dim) ! 0;
                for i in [1..dim] do
                    for j in [1..dim] do
                        Gram[i][j] := Trace(alpha*ZBase[i]*ComplexConjugate(ZBase[j]));
                    end for;
                end for;

                L := LLL(Seysen(LLL(LatticeWithGram(Gram))));

                Append(~Lattices, L);
            end for;
        end for;
    end for;

    return Lattices;

end function;

RedByIso := function(Lattices)
// Takes a list of lattices and returns the sublist of non-isometric elements.
// Input:
//  Lattices : SeqEnum      : List of lattices that shall be reduced.

// Output:
//  SeqEnum                 : Reduced list for which the elements are pairwise non-isometric    

    LatticesReduced := [];
    for L in Lattices do
        new := true;
        for M in LatticesReduced do
            if IsIsometric(L[1], M[1]) then
                new := false;
                break;
            end if;
        end for;

        if new then
            Append(~LatticesReduced, L);
        end if;
    end for;

    return LatticesReduced;

end function;

//FindModularIdealLattices := function(m, l, verbose)
//    dim := EulerPhi(m);

//    K<z> := CyclotomicField(m);
//    F := sub<K|z+1/z>;
//    ZK := LLL(MaximalOrder(K));
//    ZF := LLL(MaximalOrder(F));

//    if verbose then printf "Compute class group of Z_K...\n"; end if;

//    if verbose then printf "Done! Found %o classes modulo Galois.\n\n", #ClassRepresentationSystem; end if;

  //  if verbose then printf "Computing representative system U of totally positive elements of (Z_F)* modulo c*conj(c) for c in (Z_K)*...\n"; end if;

    //if verbose then printf "Done! %o units found.\n\n", #U; end if;

    //if verbose then printf "Computing alpha_0...\n"; end if;

//    if verbose then printf "Done!\n\n"; end if;

//    if verbose then printf "Done! %o possible divisors found.\n\n", #A; end if;

//    if verbose then printf "Now searching for modular ideal lattices...\n"; end if;
    
//    if verbose then printf "Done! Found %o modular lattices. Now reducing by isometry.\n\n", #Lattices; end if;

//    printf "Done! Found %o non-isometric %o-modular ideal lattices.\n\n", #Lattices, l;
//end function;