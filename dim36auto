
function KneserNeighboringMethod(dim, det, min)
	Rat := RationalsAsNumberField();
	Int := Integers(Rat);
	
	primes := PrimeBasis(det);
	exps := [Valuation(det, p) : p in primes];

	IdealList := [];
	if not 2 in primes then
		Append(~IdealList, <ideal<Int|2>, [[0,dim]]>);
	end if;

	for i in [1..#primes] do
		p := primes[i];
		e := Abs(exps[i]);
		if dim eq e then
			Append(~IdealList, <ideal<Int|p>, [[1,e]]>);
		else
			Append(~IdealList, <ideal<Int|p>, [[0,dim-e],[1,e]]>);
		end if;
	end for;

	Rep := LatticesWithGivenElementaryDivisors(Rat, dim, IdealList);

	Lat := [];
	for L in Rep do
		CorrectGenus := true;
		if IsEven(Integers() ! ev[1] where _,_,_,ev := GenusSymbol(L, ideal<Int|2>)) then
			B:= Matrix(ZBasis(L`Module));
			G:= B * L`Form * InternalConjugate(L, B);
			Form:= Matrix( Ncols(G), [ AbsoluteTrace(e) : e in Eltseq(G) ] );
			Form:=IntegralMatrix(Form);

			LZ := LatticeWithGram(LLLGram(Matrix(Integers(),Form)));
			Append(~Lat, LZ);
		end if;
	end for;

	Candidates := [];

	for L in Lat do
		Ma := Mass(L);

		Gen := [<L,false, 1>];
		NumShortest := [#ShortestVectors(L)];
		AutoSize := [#AutomorphismGroup(L)];

		if IsEven(L) and Minimum(L) ge min then
    		"Found a new possible candidate for F.";
			Append(~Candidates, L);
			break;
		end if;

		m := 1/AutoSize[1];

		while m ne Ma do
			
			minFound := Infinity();
			minIndex := [];
			for i in [1..#Gen] do
				if not Gen[i][2] then
					if Gen[i][3] lt minFound then
						minIndex := [i];
						minFound := Gen[i][3];
					elif Gen[i][3] eq minFound then	
						Append(~minIndex, i);
					end if;
				end if;
			end for;
			if #minIndex eq 0 then
				continue L;
			end if;
			minIndex := minIndex[Random(1, #minIndex)];


			N := Neighbours(Gen[minIndex][1], 2);
			Gen[minIndex][2] := true;

			MinAutoSize := 1/(Ma-m);
			for L in N do
				new := true;
		        
		        auto := #AutomorphismGroup(L);
		        autoInv := 1/auto;
		        if autoInv gt Ma-m then continue; end if;

				shortest := #ShortestVectors(L);

		        for k in [1..#Gen] do
		            if NumShortest[k] ne shortest then
		                continue;
		            end if;

		            if AutoSize[k] ne auto then
		                continue;
		            end if;

		            if IsIsometric(Gen[k][1], L) then
		            	Gen[k][3] +:= 1;
		                new := false;
		                break;
		            end if;
		        end for;

		        if new then
		        	m +:= autoInv;
		        	M := LatticeWithGram(LLLGram(GramMatrix(L)));
		        	Append(~Gen, <M, false, 1>);
		        	Append(~NumShortest, shortest);
		        	Append(~AutoSize, auto);

		        	if IsEven(M) and Minimum(M) ge min then
						Append(~Candidates, M);
						break L;
					end if;

		        	if m eq Ma then
		        		break;
		        	end if;
		        end if;
			end for;


		end while;


	end for;

	return Candidates;
end function;

for i in [1..#Results] do                                                    
	i;
	t := Results[i];
	dim1 := t[2];
	dimp := t[3];
	if dim1 le 12 then
		det1 := t[1]^t[4]*3^t[5];
		if #KneserNeighboringMethod(dim1, det1, 8) eq 0 then
			"Geht nicht 1";
			continue;
		end if;
	end if;
	if dimp le 12 then
		detp := t[1]^t[4]*3^t[6];
		if #KneserNeighboringMethod(dimp, detp, 8) eq 0 then
			"Geht nicht 2";
			continue;
		end if;
	end if;
	if t[1] eq 2 then
		if dim1 le 12 then                                                     
			det1 := 3^t[5];
			if #KneserNeighboringMethod(dim1, det1, 4) eq 0 then
				"Geht nicht 3";
				continue;
			end if;
		end if;
		if dimp le 12 then
			detp := 3^t[6];
			if #KneserNeighboringMethod(dimp, detp, 4) eq 0 then
				"Geht nicht 4";
				continue;
			end if;
		end if;
	end if;
end for;
